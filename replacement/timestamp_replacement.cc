#include "cache.h"

uint32_t CACHE::timestamp_victim(uint32_t cpu, uint64_t instr_id, uint32_t set, const BLOCK *current_set, uint64_t ip, uint64_t full_addr, uint32_t timestamp)
{
    uint32_t way = 0;

    // fill invalid line first
    for (way=0; way<NUM_WAY; way++) {
        if (block[set][way].valid == false) {

            DP ( if (warmup_complete[cpu]) {
            cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " invalid set: " << set << " way: " << way;
            cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << block[set][way].address << " data: " << block[set][way].data;
            cout << dec << " lru: " << block[set][way].lru << endl; });

            break;
        }
    }

    // Timestamp victim
    if (way == NUM_WAY) {
        uint64_t max_timestamp = timestamp;
        uint32_t selected_way = NUM_WAY;
        for (way=0; way<NUM_WAY; way++) {
            if (spec_block[set][way].timestamp > max_timestamp) {

                selected_way = way;
                max_timestamp = spec_block[set][way].timestamp ;

                DP ( if (warmup_complete[cpu]) {
                cout << "[" << NAME << "] " << __func__ << " instr_id: " << instr_id << " replace set: " << set << " way: " << way;
                cout << hex << " address: " << (full_addr>>LOG2_BLOCK_SIZE) << " victim address: " << block[set][way].address << " data: " << block[set][way].data;
                cout << dec << " timestamp: " << spec_block[set][way].timestamp << endl; });

                break;
            }
        }
        way = selected_way;
        return way;
    }

    if (way == NUM_WAY) {
        cerr << "[" << NAME << "] " << __func__ << " no victim! set: " << set << endl;
        assert(0);
    }

    return way;
}

void CACHE::timestamp_update(uint32_t set, uint32_t way)
{
    
}